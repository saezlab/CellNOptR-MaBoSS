#
#  This file is part of the CNO software
#
#  Copyright (c) 2020 - Heidelberg University
#
#  File author(s): CNO developers (cno-dev@ebi.ac.uk)
#
#  Distributed under the GPLv3 License.
#  See accompanying file LICENSE.txt or copy at
#      http://www.gnu.org/licenses/gpl-3.0.html
#
#  CNO website: http://www.cellnopt.org
#
##############################################################################
# $Id$

testOnSteadyState <- function(treatmt, nameSimIndiv, CNOlist, model, timeMaxi) {
  
  ##Detect for all the nodes if they reach the steady state
  ##at the end of MaBoSS simulation. Use the files generated by MaBoSS
  ##Indicates if it need more time

  nameFolder <- paste(nameSimIndiv,treatmt,sep="_")
  nameFile <- paste(nameFolder, "_probtraj_table.csv", sep="")
  dataMB <- read.table(paste(nameFolder,nameFile,sep="/"), header = TRUE)
  

  ##Reduction of the data frame
  dataMB <- dataMB[,str_detect(colnames(dataMB), "^[Prob|Time]")]
  colnames(dataMB) <- str_replace(colnames(dataMB), "^Prob.", "")
  names <- colnames(dataMB)
  

  ##List with indices of each node in the dataMB data frame
  species <- model$namesSpecies
  indexRO <- list()
  for (node in species){
    indexRO[[node]] <- c()
      
    for (aTransState in names){
      if ((str_detect(aTransState, node)==TRUE)){
        indexRO[[node]] <- c(indexRO[[node]], which(names==aTransState))
      }
    }
  }
    

  
  qtty <- c()
  slopeValues <- c()
  rseValues <- c()
  origines <- c()
  for(node in species) {
    indices <- indexRO[[node]]
    if(is.null(dim(dataMB[,indices])) == TRUE){
      ##the node/species does not get any activation during the simulation
      qtty[[node]] <- dataMB[,indices]
    }
    else {
      ##sum of the probabilites for each time tick
      qtty[[node]] <- apply(dataMB[,indices], 1, sum)
    }
    
    ##Slope and RSE of linear Regression
    ## 1) linear regression on the 20 last values
    time <- dataMB[(dim(dataMB)[1]-20):dim(dataMB)[1],which(colnames(dataMB) == "Time")]
    regLin <- as.vector(lm(qtty[[node]][(length(qtty[[node]])-20):(length(qtty[[node]]))] ~ 
                   time))
      
    ## 2) get the slop and the RSE
    slopeValues <- c(slopeValues,regLin$coefficient[2])
    rseValues <- c(rseValues, summary(regLin)$sigma)
    origines <- c(origines, regLin$coefficient[1])

  }
  
  densityNodesMBSS(dataMB, nameFolder, timeMaxi, species, qtty, origines, slopeValues)

  ##Test iteratively the slope and the RSE of each node
  ##obtained by the linear regression
  i <- 1
  addTime <- FALSE
  while((i <= length(slopeValues) && addTime == FALSE) && (timeMaxi < max(CNOlist@timepoints)*5)){
    if (slopeValues[i] > 0.0001 || rseValues[i] > 0.0001) {
      addTime <- TRUE
      }
    i <- i + 1
  }
  
  if (addTime == TRUE) {
    timeMaxi <- timeMaxi+max(CNOlist@timepoints)
  }
  return(timeMaxi)
  
}