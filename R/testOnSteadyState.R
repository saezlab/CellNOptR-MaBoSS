#
#  This file is part of the CNO software
#
#  Copyright (c) 2020 - BioQuant Zentrum - Heidelberg University
#
#  File author(s): C. Chevalier, A. Dugourd, E. Gjerga
#
#  Distributed under the GPLv3 License.
#  See accompanying file LICENSE.txt or copy at
#      http://www.gnu.org/licenses/gpl-3.0.html
#
#  CNO website: http://www.cellnopt.org
#
##############################################################################
# $Id$

testOnSteadyState <- function(treatmt, nameSimIndiv, CNOlist, model, timeMaxi) {
  # ====== Detect for all the nodes if they reach the steady state ====== #
  # == at the end of MaBoSS simulation. Use the files generated by MaBoSS == #
  # == Indicates if it need more time == #

  nameFolder <- paste(nameSimIndiv,treatmt,sep="_")
  nameFile <- paste(nameFolder, "_probtraj_table.csv", sep="")
  dataMB <- read.table(paste(nameFolder,nameFile,sep="/"), header = TRUE)
  

  # ====== Reduction of the data frame ====== #
  dataMB <- dataMB[,str_detect(colnames(dataMB), "^[Prob|Time]")]
  colnames(dataMB) <- str_replace(colnames(dataMB), "^Prob.", "")
  names <- colnames(dataMB)
  

  # ====== List with indices of each node in the dataMB data frame ====== #
  species <- model$namesSpecies
  indexRO <- list()
  for (node in species){
    indexRO[[node]] <- c()
      
    for (aTransState in names){
      if ((str_detect(aTransState, node)==TRUE)){
        indexRO[[node]] <- c(indexRO[[node]], which(names==aTransState))
      }
    }
  }
    

  
  qtty <- c()
  #cmpValues <- c()
  slopeValues <- c()
  rseValues <- c()
  origines <- c()
  for(node in species) {
    indices <- indexRO[[node]]
    if(is.null(dim(dataMB[,indices])) == TRUE){
      # ====== the node/species does not get any activation during the simulation ====== #
      qtty[[node]] <- dataMB[,indices]
    }
    else {
      # ====== sum of the probabilites for each time tick ====== #
      qtty[[node]] <- apply(dataMB[,indices], 1, sum)
    }
    
    #####################
    ### Standard Deviation
    #lastValues <- qtty[[node]][(length(qtty[[node]])-19):(length(qtty[[node]]))]
    #sdLV <- sd(lastValues)
    #cmpValues <- c(cmpValues, sdLV)
    
    #####################
    ### Comparison of 2 values
    #cmpValues <- c(cmpValues, abs(qtty[[node]][length(qtty[[node]])-9] - qtty[[node]][length(qtty[[node]])]))
    
    #####################
    ### Comparison of the last values
    #totDiff <- 0
    #for (i in 1:9){
    #  totDiff <- totDiff + abs(qtty[[node]][length(qtty[[node]])] - qtty[[node]][length(qtty[[node]])-i])
    #}
    #cmpValues <- c(cmpValues, totDiff)
    #print(cmpValues)
      
    # ====== Slope and RSE of linear Regression ====== #
    # 1) linear regression on the 20 last values
    time <- dataMB[(dim(dataMB)[1]-20):dim(dataMB)[1],which(colnames(dataMB) == "Time")]
    regLin <- as.vector(lm(qtty[[node]][(length(qtty[[node]])-20):(length(qtty[[node]]))] ~ 
                   time))
      
    # 2) get the slop and the RSE
    slopeValues <- c(slopeValues,regLin$coefficient[2])
    rseValues <- c(rseValues, summary(regLin)$sigma)
    origines <- c(origines, regLin$coefficient[1])

    #####################
    ### Get the pvalue of the linear regression
    #print(qtty[[node]][(length(qtty[[node]])-19):(length(qtty[[node]]))])
    # 1) linear regression on the last values
    #time <- dataMB[(dim(dataMB)[1]-19):dim(dataMB)[1],which(colnames(dataMB) == "Time")]
    #regLin <- lm(qtty[[node]][(length(qtty[[node]])-19):(length(qtty[[node]]))] ~ 
    #               time)
    
    # 2) get the slope
    #cmpValues <- c(cmpValues,summary(regLin)$coefficients[[8]])

  }
  
  # ====== Function to plot the density of the nodes along the simulation ====== #
  # == the dotted lines are the regressed model obtained over the 20 last values == #
  densityNodesMBSS <- function(dataMB, nameFolder, timeMaxi, species, qtty) {
    myPath <- getwd()
    timeSeq <- dataMB[,which(colnames(dataMB) == "Time")]
    pdf(paste(myPath,"/allCond/",nameFolder, "_", timeMaxi,".pdf", sep=""))
    par(mfrow=c(1,1))
    vecCol <- rainbow(length(species)-1)
    plot(timeSeq, unlist(qtty[[1]]), type="l", col=1, ylim = c(0,1),
      main = paste(nameFolder,"_", timeMaxi, sep=""))
    for (i in 2:length(species)){
      spec <- species[i]
      lines(timeSeq, unlist(qtty[[spec]]), col=vecCol[i-1])
      abline(origines[i],slopeValues[i], col=vecCol[i-1], lty="dotdash")
    }
    abline(v=c(timeSeq[length(timeSeq)-20]), col="black")
    legend("right", legend = names(qtty), col = c(1,vecCol), lwd = 1)
    dev.off()
  }

  densityNodesMBSS(dataMB, nameFolder, timeMaxi, species, qtty)


    #####################
    ### Test when using comparison
    #print(cmpValues)
    #i <- 1
    #addTime <- FALSE
    #while(i <= length(cmpValues) && addTime == FALSE){
    #  if (cmpValues[i] > 0.001 || cmpValues[i] < -0.001) {
    #    addTime <- TRUE
    #  }
    #  i <- i + 1
    #}
    #print(i-1)
    
    #####################
    ### t.test on the Entropy
    #for(node in colnames(CNOlist@signals)){
    #  evalSS <- t.test(qtty[[node]][ (length(qtty[[node]])-100) : (length(qtty[[node]])-41) ],
    #                   qtty[[node]][ (length(qtty[[node]])-40) : (length(qtty[[node]]))],
    #                   alternative = "two.sided"
    #  )
    #  if (evalSS$p.value < 0.05) {
    #    addTime <- TRUE
    #  }
    #}
    
    #####################
    ### pvalue of the linear regression
    #i <- 1
    #addTime <- FALSE
    #cmpValues <- na.omit(cmpValues)
    #while(i <= length(cmpValues) && addTime == FALSE){
    #  if (cmpValues[i] < 0.05) {
    #    addTime <- TRUE
    #  }
    #  i <- i + 1
    #}
    
  
  # ====== Test iteratively the slope and the RSE of each node ====== #
  # == obtained by the linear regression == #
  i <- 1
  addTime <- FALSE
  while((i <= length(slopeValues) && addTime == FALSE) && (timeMaxi < max(CNOlist@timepoints)*5)){
    if (slopeValues[i] > 0.0001 || rseValues[i] > 0.0001) {
      addTime <- TRUE
      }
    i <- i + 1
  }
  
  if (addTime == TRUE) {
    timeMaxi <- timeMaxi+max(CNOlist@timepoints)
  }
  return(timeMaxi)
}